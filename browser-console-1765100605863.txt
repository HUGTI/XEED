VM12983:8 Console was cleared
VM12983:9 üîê CANVAS SECURITY AUDIT
VM12983:29 üéØ Target Canvas: {className: 'thimbles__canvas', dimensions: '849x919', crossOrigin: undefined, hasCrossOriginAttr: false, crossoriginValue: null}
VM12983:37 üîç Running comprehensive taint tests...

VM12983:48 1Ô∏è‚É£ Direct Pixel Read Test:
VM12983:59    ‚ö†Ô∏è No 2D context available
VM12983:344 
============================================================
VM12983:345 üìã COMPLETE SECURITY AUDIT REPORT
VM12983:427 
üí° Quick commands:
VM12983:428    window.__canvasAudit.testPixelRead() - Test pixel reading
VM12983:429    window.__canvasAudit.rerun() - Run full audit again
undefined
VM12983:71 2Ô∏è‚É£ WebGL Pixel Read Test:
VM12983:79    ‚úÖ Success - WebGL pixel: Uint8Array(4)¬†[0, 0, 0, 255, buffer: ArrayBuffer(4), byteLength: 4, byteOffset: 0, length: 4, Symbol(Symbol.toStringTag): 'Uint8Array']
VM12983:95 3Ô∏è‚É£ toDataURL() Test:
VM12983:100    ‚úÖ Success - Data URL generated
VM12983:101    üìä Data URL length: 28446 chars
VM12983:112    üé® First pixel from data URL: Uint8ClampedArray(4)¬†[0, 0, 0, 255, buffer: ArrayBuffer(4), byteLength: 4, byteOffset: 0, length: 4, Symbol(Symbol.toStringTag): 'Uint8ClampedArray']
VM12983:115    ‚ö†Ô∏è Data URL contains BLACK image (not tainted, just empty)
VM12983:132 4Ô∏è‚É£ toBlob() Test:
VM12983:138    ‚úÖ Success - Blob created: 17494 bytes
VM12983:156 5Ô∏è‚É£ captureStream() Test:
VM12983:166    ‚úÖ Success - Stream captured
VM12983:167    üìπ Stream active: true
VM12983:168    üéûÔ∏è Tracks: 1
VM12983:180 6Ô∏è‚É£ CORS Header Check:
VM12983:188    üìã Canvas Attributes:
VM12983:189       - crossorigin attribute exists: false
VM12983:190       - crossorigin attribute value: null
VM12983:191       - canvas.crossOrigin property: undefined
VM12983:199    ‚ö†Ô∏è CORS attributes missing or incorrect
VM12983:200    üí° Setting CORS attributes...
VM12983:208 7Ô∏è‚É£ Resource Loading Test:
VM12983:224    ‚úÖ Test image loaded and drawn successfully
VM12983:246 8Ô∏è‚É£ Context Taint Check:
VM12983:258    üìä WebGL Context Attributes: {alpha: false, antialias: false, depth: true, desynchronized: false, failIfMajorPerformanceCaveat: false,¬†‚Ä¶}
VM12983:268    ‚úÖ WebGL context accepts texture uploads
VM12983:362 JSON Report: {
  "timestamp": "2025-12-07T09:40:53.234Z",
  "canvas": {
    "className": "thimbles__canvas",
    "dimensions": "849x919",
    "crossOrigin": "anonymous",
    "hasCrossOriginAttr": true
  },
  "results": {
    "tainted": null,
    "readable": true,
    "securityErrors": [],
    "testsPassed": 6,
    "testsTotal": 8
  },
  "verdict": "READABLE"
}
VM12983:366 
üìÑ Report available at: window.__canvasAuditReport
VM12983:297 
============================================================
VM12983:298 üìä FINAL TAINT ANALYSIS
VM12983:304 ‚úÖ CANVIS IS READABLE (NOT TAINTED)
VM12983:311 Tests Passed: 6/8
VM12983:319 
üí° RECOMMENDATIONS:
VM12983:333 ‚úÖ Canvas is secure and readable
VM12983:334 You can safely use:
VM12983:335    - getImageData()
VM12983:336    - toDataURL()
VM12983:337    - toBlob()
VM12983:338    - captureStream()
// Run this FIRST to see if canvas is tainted
(()=>{const c=document.querySelector('canvas.thimbles__canvas');if(!c)return console.log('‚ùå Canvas not found');try{const ctx=c.getContext('2d')||c.getContext('webgl')||c.getContext('webgl2');if(ctx.getImageData){const d=ctx.getImageData(0,0,1,1);console.log('‚úÖ Canvas READABLE - Pixel:',d.data);return true}else if(ctx.readPixels){const p=new Uint8Array(4);ctx.readPixels(0,0,1,1,ctx.RGBA,ctx.UNSIGNED_BYTE,p);console.log('‚úÖ Canvas READABLE - WebGL pixel:',p);return true}}catch(e){console.log('‚ùå Canvas TAINTED - Error:',e.message);return false}})()
VM12987:2 ‚úÖ Canvas READABLE - WebGL pixel: Uint8Array(4)¬†[0, 0, 0, 255, buffer: ArrayBuffer(4), byteLength: 4, byteOffset: 0, length: 4, Symbol(Symbol.toStringTag): 'Uint8Array']
true
// Check if CORS attributes are properly set
(()=>{const c=document.querySelector('canvas.thimbles__canvas');console.log('üìã CORS Status:');console.log('- crossorigin attribute:',c.hasAttribute('crossorigin'));console.log('- attribute value:',c.getAttribute('crossorigin'));console.log('- canvas.crossOrigin:',c.crossOrigin);console.log('- Recommendation:',c.crossOrigin==='anonymous'?'‚úÖ Good':'‚ö†Ô∏è Set: canvas.crossOrigin="anonymous"')})()
VM12991:2 üìã CORS Status:
VM12991:2 - crossorigin attribute: true
VM12991:2 - attribute value: anonymous
VM12991:2 - canvas.crossOrigin: anonymous
VM12991:2 - Recommendation: ‚úÖ Good
undefined
// Distinguish between "black from clearing" vs "tainted security error"
(()=>{const c=document.querySelector('canvas.thimbles__canvas');console.log('üîç Testing: Black canvas or Tainted?');try{const data=c.toDataURL('image/png');console.log('‚úÖ toDataURL() works - Canvas NOT tainted');const img=new Image();img.onload=()=>{const t=document.createElement('canvas');t.width=img.width;t.height=img.height;const ctx=t.getContext('2d');ctx.drawImage(img,0,0);const p=ctx.getImageData(0,0,1,1).data;console.log('üé® Pixel from data URL:',p);console.log(p[0]==0&&p[1]==0&&p[2]==0?'‚ö†Ô∏è Image is BLACK (not tainted)':'‚úÖ Image has content');};img.src=data;}catch(e){console.log(e.name==='SecurityError'?'‚ùå Canvas TAINTED (SecurityError)':'‚ùå Other error:',e.message)}})()
VM12995:2 üîç Testing: Black canvas or Tainted?
VM12995:2 ‚úÖ toDataURL() works - Canvas NOT tainted
undefined
VM12995:2 üé® Pixel from data URL: Uint8ClampedArray(4)¬†[0, 0, 0, 255, buffer: ArrayBuffer(4), byteLength: 4, byteOffset: 0, length: 4, Symbol(Symbol.toStringTag): 'Uint8ClampedArray']
VM12995:2 ‚ö†Ô∏è Image is BLACK (not tainted)
// Apply these fixes
const canvas = document.querySelector('canvas.thimbles__canvas');
canvas.setAttribute('crossorigin', 'anonymous');
canvas.crossOrigin = 'anonymous';

// Also ensure your server sends these headers:
// Access-Control-Allow-Origin: *
// Access-Control-Allow-Credentials: true
// Access-Control-Allow-Headers: *
'anonymous'
// The issue is preserveDrawingBuffer: false
// Try these capture methods:

// Method A: Hook into animation loop
const originalRAF = window.requestAnimationFrame;
window.requestAnimationFrame = function(callback) {
    return originalRAF(function(timestamp) {
        callback(timestamp);
        // Capture RIGHT AFTER rendering
        setTimeout(() => {
            const temp = document.createElement('canvas');
            temp.width = canvas.width;
            temp.height = canvas.height;
            const ctx = temp.getContext('2d');
            ctx.drawImage(canvas, 0, 0);
            // Check pixel
            const pixel = ctx.getImageData(50, 50, 1, 1).data;
            if (pixel[0] > 0 || pixel[1] > 0 || pixel[2] > 0) {
                console.log('‚úÖ Captured visible frame!');
            }
        }, 0);
    });
};

// Method B: Use video recording
if (canvas.captureStream) {
    const stream = canvas.captureStream(30);
    const recorder = new MediaRecorder(stream);
    // Record and save video
}
undefined
// PASTE THIS IN CONSOLE - Complete Verification Checklist
const checklist = async () => {
    const canvas = document.querySelector('canvas.thimbles__canvas');
    const results = [];
    
    // 1. Check CORS attributes
    const hasCORS = canvas.hasAttribute('crossorigin') && canvas.crossOrigin === 'anonymous';
    results.push({test: 'CORS Attributes', passed: hasCORS});
    
    // 2. Try getImageData
    try {
        const ctx = canvas.getContext('2d');
        if (ctx) {
            ctx.getImageData(0, 0, 1, 1);
            results.push({test: 'getImageData()', passed: true, tainted: false});
        } else {
            results.push({test: 'getImageData()', passed: false, reason: 'No 2D context'});
        }
    } catch(e) {
        results.push({test: 'getImageData()', passed: false, tainted: true, error: e.message});
    }
    
    // 3. Try toDataURL
    try {
        const dataURL = canvas.toDataURL();
        results.push({test: 'toDataURL()', passed: true, length: dataURL.length});
    } catch(e) {
        results.push({test: 'toDataURL()', passed: false, tainted: e.name === 'SecurityError', error: e.message});
    }
    
    // 4. Check if black or has content
    const temp = document.createElement('canvas');
    temp.width = canvas.width;
    temp.height = canvas.height;
    const tempCtx = temp.getContext('2d');
    tempCtx.drawImage(canvas, 0, 0);
    const pixel = tempCtx.getImageData(0, 0, 1, 1).data;
    const isBlack = pixel[0] === 0 && pixel[1] === 0 && pixel[2] === 0;
    results.push({test: 'Canvas Content', hasContent: !isBlack, pixel: pixel});
    
    // Display results
    console.table(results);
    
    // Final verdict
    const tainted = results.some(r => r.tainted === true);
    const readable = results.every(r => r.passed !== false || r.reason === 'No 2D context');
    
    if (tainted) {
        console.log('%c‚ùå FINAL: Canvas IS TAINTED', 'color: red; font-size: 20px;');
    } else if (readable && !isBlack) {
        console.log('%c‚úÖ FINAL: Canvas is READABLE with CONTENT', 'color: green; font-size: 20px;');
    } else if (readable && isBlack) {
        console.log('%c‚ö†Ô∏è FINAL: Canvas is READABLE but BLACK', 'color: orange; font-size: 20px;');
        console.log('This is due to preserveDrawingBuffer: false, not tainting.');
    } else {
        console.log('%c‚ùì FINAL: Inconclusive', 'color: yellow; font-size: 20px;');
    }
};

checklist();
VM13006:42 (index)testpassedreasonlengthhasContentpixel(index)testpassedreasonlengthhasContentpixel0'CORS Attributes'true1'getImageData()'false'No 2D context'2'toDataURL()'true284463'Canvas Content'falseUint8ClampedArray(4)Array(4)
VM13006:53 ‚ö†Ô∏è FINAL: Canvas is READABLE but BLACK
VM13006:54 This is due to preserveDrawingBuffer: false, not tainting.
Promise¬†{<fulfilled>: undefined}
